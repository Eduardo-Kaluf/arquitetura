\documentclass{article}

\usepackage{amsmath} 
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{array}
\usepackage{indentfirst}
\usepackage{booktabs}
\usepackage[table]{xcolor} 
\usepackage{tikz}
\usepackage{caption}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{textcomp}






\lstdefinelanguage{ReduxAsm}{
  keywords={brzr, ji, ld, st, addi, inc, loadv, addv, not, and, or, xor, add, sub, slr, srr, strue, mult-op, sgt, f-mov, seq, f-st, f-brzi, f-add, f-ld,
            s.ld, s.st, s.movh, s.movl, s.add, s.sub, s.and, s.brzr, v.ld, v.st, v.movh, v.movl, v.add, v.sub, s.inc-ops, s.rep},
  morecomment=[l]{;},
  sensitive=true
}

\lstset{
  language=ReduxAsm,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  frame=single,
  columns=fullflexible
}

\usetikzlibrary{matrix}

\DeclareMathAlphabet{\mathcal}{OMS}{cmsy}{m}{n}
\SetMathAlphabet{\mathcal}{bold}{OMS}{cmsy}{b}{n}
\title{Trabalho 3 - VLIW e Vetorial}
\author{SERGIO SIVONEI DE SANT'ANA FILHO GRR20242337\\EDUARDO KALUF GRR20241770}
\date{\today} 


\begin{document}
    \maketitle
    
    \section{Apresentação}
    
    Ao decorrer da disciplina aprendemos inúmeras maneiras de realizar a implementação de um processador, o modo como operam, seus prós e contras e seus contextos históricos. Sendo assim, neste trabalho iremos nos aprofundar em duas dessas maneiras sendo elas o VLIW e o processador Vetorial, o objetivo é a partir de uma ISA já predefinida (SAGUI) criar o projeto de ambos os processadores utilizando \href{https://github.com/logisim-evolution/logisim-evolution}{\textbf{Logisim}}, criar duas instruções adicionais para cada ISA e então realizar a execução de um programa assembly em cada um deles.

    Para cada um dos processadores iremos utilizar uma ISA diferente que deriva do SAGUI, no caso do VLIW será o Sagui de rabo longo, já para o vetorial o Sagui em bando, além disso, o programa assembly teste consiste em fazer a soma de dois vetores com 12 posições e guardar os resultados na memória, com todos os vetores alinhados.
    Devido a maneira de como os processadores operam, cada um deles terá um programa Assembly diferente, porém que deverá apresentar o mesmo resultado.

    \section{VLIW}
    
    \subsection{Arquitetura}

    VLIW significa "Very long instruction Word" que se traduz para "palavra de instrução muito grande" e a ideia do processador gira exatamente em torno disso, basicamente, iremos ter uma palavra grande que carrega mais de uma instrução dentro dela, no nosso caso, 4 instruções, dessa forma o processador irá executa-las em paralelo aumentando o IPC total.
    No VLIW a responsabilidade de evitar dependencias e escritas simultaneas ficam completamente na mão do compilador, o qual utiliza diversas técnicas como loop unroling e predicação a fim de diminuir a quantidade de NOPS necessários, fazendo com que o código seja executado de maneira mais otimizada.

    \subsection{ISA}

    A ISA que iremos utilizar para o nosso VLIW é a Sagui de Rabo Longo (SRB) com algumas modificações para operar com predicação.
    A SRB consiste em uma ISA parecida com a REDUX-V, sendo tão compacta e amigável quanto para quem está iniciando no mundo da arquitetura de computadores. 
    Ela possui 8 bits com 4 registradores de propósito geral e será endereçada de palavra a palavra ou seja de 4 em 4 bytes, além de definir 4 "lanes" diferentes, esses "lanes" são os tipos de operação (Branch, aritmética, lógica e etc...) que cada posição da palavra do VLIW poderá realizar. O opcode possui 4 bits, fazendo com que possamos operar 16 instruçoes diferentes, devido as modificações para predicação as instruções serão apresentadas mais a frente já em suas lanes específicas.
    
    Por padrão, os formatos das instruções e as lanes são definidas a seguir:

    \begin{table}[h]
      \captionsetup{labelformat=empty, skip=0pt}
      \caption{\textbf{Formato Padrão 1:} Tipo I}
      \centering
      \rowcolors{1}{white}{green!20} 
      \begin{tabular}{|c|*{8}{c|}}
        \hline
        \rowcolor{green!50}
        \multicolumn{9}{|c|}{\textbf{Tipo I}} \\ \hline
        \textbf{Bits} & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\ \hline
        & \multicolumn{4}{c|}{\textbf{Opcode}} & \multicolumn{4}{c|}{\textbf{Imm.}} \\ \hline
      \end{tabular}
    \end{table}

    \begin{table}[h]
      \captionsetup{labelformat=empty, skip=0pt}
      \caption{\textbf{Formato Padrão 2:} Tipo R}
      \centering
      \rowcolors{1}{white}{blue!20} 
      \begin{tabular}{|c|*{8}{c|}}
        \hline
        \rowcolor{blue!50}
        \multicolumn{9}{|c|}{\textbf{Tipo R}} \\ \hline
        \textbf{Bits} & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\ \hline
        & \multicolumn{4}{c|}{\textbf{Opcode}} & \multicolumn{2}{c|}{\textbf{Ra}} & \multicolumn{2}{c|}{\textbf{Rb}} \\ \hline
      \end{tabular}
    \end{table}

    \begin{figure}[H]
        \captionsetup{labelformat=empty, skip=0pt}
        \caption{\textbf{Lanes:}}
        \centering 
        \begin{tikzpicture}
            \matrix[matrix of nodes, 
                    nodes in empty cells,
                    nodes={draw, minimum size=1.5cm, anchor=center},
                    column sep=0pt] (m) {
            {\text{1º}} & {\text{2º}} & {\text{3º}} & {\text{4º}} \\
            };

            \node[yshift=6pt] at (m-1-1.north) {\small Dados};
            \node[yshift=6pt] at (m-1-2.north) {\small Controle};
            \node[yshift=6pt] at (m-1-3.north) {\small ULA};
            \node[yshift=6pt] at (m-1-4.north) {\small ULA};
        \end{tikzpicture}
    \end{figure}

    \subsection{Motivações e Instruções}

    Para este processador gostariamos de dar a maior quantidade de operações lógicas possíveis ao programador e uma facilidade maior para mexer com loops, adicionando outra instrução branch de controle. Além disso, para que a utilização de predicados seja viável, adaptamos a ISA de modo que ela possua um conjunto de instruções específicas para cada uma das lanes do VLIW e instruções para settar o predicado na parte de controle

    \subsubsection{Multi Operations}

    A primeira escolha de instrução foi a de 'multioperações' (MULTIOPS), a qual é do tipo misto (INC) tendo um
    registrador indicado e um imediato de 0 a 3.

    Essa instrução funciona como um grupo de 4 instruções simples, sendo elas: NOT(logico), XOR, AND e XNOR. Todos
    operando sobre R0 (que é sempre o registrador destino) e Ra (por Ra entenda registrador descrito na instrução).

    Ela segue o formato OPCODE nos 4 últimos bits e nos outros 4 ela divide em metade para indicar o
    Ra e outra para um numero de 0 a 3, o qual indica qual operação deve ser realizada, NOT(0), XOR(1),
    AND(2) e XNOR(3).


    \begin{table}[h]
      \captionsetup{labelformat=empty, skip=0pt}
      \caption{\textbf{Formato Novo:} Tipo Misto}
      \centering
      \rowcolors{1}{white}{red!20} 
      \begin{tabular}{|c|*{8}{c|}}
        \hline
        \rowcolor{red!50}
        \multicolumn{9}{|c|}{\textbf{Tipo M}} \\ \hline
        \textbf{Bits} & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\ \hline
        & \multicolumn{4}{c|}{\textbf{Opcode}} & \multicolumn{2}{c|}{\textbf{Ra}} & \multicolumn{2}{c|}{\textbf{Imm Unsigned}} \\ \hline
      \end{tabular}
    \end{table}


    \subsubsection{Move}

    A instrução move faz uso da logica de copiar o valor de um registrador para outro, coisa que é 
    útil em casos com grande limitação (como no nosso caso). Isso se dá por, por exemplo, só podermos alterar
    diretamente o valor de R0 (usando as funções movh/movl).
    Essa função faz Ra receber Rb, sobrescrevendo o conteudo anterior de Ra. Tal lógica retira a necessidade de
    zerar um registrador para depois somar por exemplo.

    \subsubsection{Predicação}

    A fim de aproveitar que temos 16 instruções disponíveis por LANE, fizemos a implementação de um sistema de predicados em nosso processador.
    Temos 4 instruções responsáveis por controlar o valor do predicado (TRUE ou FALSE) e então todas as outras instruções possuem um espelho de si mesmas, a primeira funcionando quando o predicado é true e a segunda quando o mesmo é falso.
    Dessa forma o programador pode fazer o caminho verdadeiro de um if junto com o caminho falso, diminuindo a quantidade de dependencias no código.
    Vale a pena resaltar que uma das instruções é o STRUE, a ideia é que ela seja utilizada em conjunto com as instruções que executam o caminho verdadeiro quando nenhuma predicação está acontecendo, assim evitamos criar um terceiro espelho de cada instrução que funcione independente do valor do predicado
    As 4 instruçoes estão apresentadas abaixo juntamente com a tabela final de cada uma das LANES    

    \begin{table}[H]
      \centering
      \captionsetup{labelformat=empty, skip=0pt}
      \caption{\textbf{Lane 1 Instruções: Dados}}
      \noindent\hspace*{-1.25cm}
      \rowcolors{1}{white}{gray!20} 
      \begin{tabular}{|c|*{4}{c|}}
        \hline
        \rowcolor{gray!50}
        \multicolumn{1}{|c|}{\textbf{Opcode}} & \multicolumn{1}{|c|}{\textbf{Tipo}} & \multicolumn{1}{|c|}{\textbf{Mnemonic}} & \multicolumn{1}{|c|}{\textbf{Nome}}        & \multicolumn{1}{|c|}{\textbf{Operação}}                      \\ \hline
        \multicolumn{5}{|c|}{\textbf{Dados}} \\ \hline 
        \multicolumn{1}{|c|}{\textbf{0000}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{ld}}        & \multicolumn{1}{c|}{\textbf{Load}}         & \multicolumn{1}{c|}{\textbf{R[ra] = M[ R[rb] ] if PR}}       \\ \hline
        \multicolumn{1}{|c|}{\textbf{0001}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{st}}        & \multicolumn{1}{c|}{\textbf{Store}}        & \multicolumn{1}{c|}{\textbf{M[ R[rb] ] = R[ra] if PR}}       \\ \hline
        \multicolumn{1}{|c|}{\textbf{0010}}   & \multicolumn{1}{c|}{\textbf{I}}     & \multicolumn{1}{c|}{\textbf{movh}}      & \multicolumn{1}{c|}{\textbf{Move High}}    & \multicolumn{1}{c|}{\textbf{R[0] = {Imm, R[0](3:0)} if PR}}  \\ \hline
        \multicolumn{1}{|c|}{\textbf{0011}}   & \multicolumn{1}{c|}{\textbf{I}}     & \multicolumn{1}{c|}{\textbf{movl}}      & \multicolumn{1}{c|}{\textbf{Move Low}}     & \multicolumn{1}{c|}{\textbf{R[0] = {R[0](7:4), Imm} if PR}}  \\ \hline
        \multicolumn{1}{|c|}{\textbf{0100}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{f-ld}}      & \multicolumn{1}{c|}{\textbf{!Load}}        & \multicolumn{1}{c|}{\textbf{R[ra] = M[ R[rb] ] if !PR}}      \\ \hline
        \multicolumn{1}{|c|}{\textbf{0101}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{f-st}}      & \multicolumn{1}{c|}{\textbf{!Store}}       & \multicolumn{1}{c|}{\textbf{M[ R[rb] ] = R[ra] if !PR}}      \\ \hline
        \multicolumn{1}{|c|}{\textbf{0110}}   & \multicolumn{1}{c|}{\textbf{I}}     & \multicolumn{1}{c|}{\textbf{f-movh}}    & \multicolumn{1}{c|}{\textbf{!Move High}}   & \multicolumn{1}{c|}{\textbf{R[0] = {Imm, R[0](3:0)} if !PR}} \\ \hline
        \multicolumn{1}{|c|}{\textbf{0111}}   & \multicolumn{1}{c|}{\textbf{I}}     & \multicolumn{1}{c|}{\textbf{f-movl}}    & \multicolumn{1}{c|}{\textbf{!Move Low}}    & \multicolumn{1}{c|}{\textbf{R[0] = {R[0](7:4), Imm} if !PR}} \\ \hline
        \multicolumn{1}{|c|}{\textbf{1000}}   & \multicolumn{1}{c|}{\textbf{EMPTY}} & \multicolumn{1}{c|}{\textbf{EMPTY}}     & \multicolumn{1}{c|}{\textbf{EMPTY}}        & \multicolumn{1}{c|}{\textbf{EMPTY}}                          \\ \hline
        \multicolumn{1}{|c|}{\textbf{1001}}   & \multicolumn{1}{c|}{\textbf{EMPTY}} & \multicolumn{1}{c|}{\textbf{EMPTY}}     & \multicolumn{1}{c|}{\textbf{EMPTY}}        & \multicolumn{1}{c|}{\textbf{EMPTY}}                          \\ \hline
        \multicolumn{1}{|c|}{\textbf{1010}}   & \multicolumn{1}{c|}{\textbf{EMPTY}} & \multicolumn{1}{c|}{\textbf{EMPTY}}     & \multicolumn{1}{c|}{\textbf{EMPTY}}        & \multicolumn{1}{c|}{\textbf{EMPTY}}                          \\ \hline
        \multicolumn{1}{|c|}{\textbf{1011}}   & \multicolumn{1}{c|}{\textbf{EMPTY}} & \multicolumn{1}{c|}{\textbf{EMPTY}}     & \multicolumn{1}{c|}{\textbf{EMPTY}}        & \multicolumn{1}{c|}{\textbf{EMPTY}}                          \\ \hline
        \multicolumn{1}{|c|}{\textbf{1100}}   & \multicolumn{1}{c|}{\textbf{EMPTY}} & \multicolumn{1}{c|}{\textbf{EMPTY}}     & \multicolumn{1}{c|}{\textbf{EMPTY}}        & \multicolumn{1}{c|}{\textbf{EMPTY}}                          \\ \hline
        \multicolumn{1}{|c|}{\textbf{1101}}   & \multicolumn{1}{c|}{\textbf{EMPTY}} & \multicolumn{1}{c|}{\textbf{EMPTY}}     & \multicolumn{1}{c|}{\textbf{EMPTY}}        & \multicolumn{1}{c|}{\textbf{EMPTY}}                          \\ \hline
        \multicolumn{1}{|c|}{\textbf{1110}}   & \multicolumn{1}{c|}{\textbf{EMPTY}} & \multicolumn{1}{c|}{\textbf{EMPTY}}     & \multicolumn{1}{c|}{\textbf{EMPTY}}        & \multicolumn{1}{c|}{\textbf{EMPTY}}                          \\ \hline
        \multicolumn{5}{|c|}{\textbf{Free Slot}}                                                                                                                                                                                          \\ \hline 
        \multicolumn{1}{|c|}{\textbf{1111}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{nop}}       & \multicolumn{1}{c|}{\textbf{No Operation}} & \multicolumn{1}{c|}{\textbf{}}                               \\ \hline
      \end{tabular}
    \end{table}

    \begin{table}[H]
      \centering
      \captionsetup{labelformat=empty, skip=0pt}
      \caption{\textbf{Lane 2 Instruções: Controle}}
      \rowcolors{1}{white}{gray!20} 
      \noindent\hspace*{-3.5cm}
      \begin{tabular}{|c|*{4}{c|}}
        \hline
        \rowcolor{gray!50}
        \multicolumn{1}{|c|}{\textbf{Opcode}} & \multicolumn{1}{|c|}{\textbf{Tipo}} & \multicolumn{1}{|c|}{\textbf{Mnemonic}} & \multicolumn{1}{|c|}{\textbf{Nome}}                     & \multicolumn{1}{|c|}{\textbf{Operação}}                                        \\ \hline
        \multicolumn{5}{|c|}{\textbf{Controle}} \\ \hline 
        \multicolumn{1}{|c|}{\textbf{0000}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{brzr}}      & \multicolumn{1}{c|}{\textbf{Branch On Zero Register}}   & \multicolumn{1}{c|}{\textbf{if (R[ra] == 0) PC = R[rb] if PR}}                 \\ \hline
        \multicolumn{1}{|c|}{\textbf{0001}}   & \multicolumn{1}{c|}{\textbf{I}}     & \multicolumn{1}{c|}{\textbf{brzi}}      & \multicolumn{1}{c|}{\textbf{Branch On Zero Immediate}}  & \multicolumn{1}{c|}{\textbf{if (R[0] == 0) PC = PC + Imm if PR}}               \\ \hline
        \multicolumn{1}{|c|}{\textbf{0010}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{jr}}        & \multicolumn{1}{c|}{\textbf{Jump Register}}             & \multicolumn{1}{c|}{\textbf{PC = R[rb] if PR}}                                 \\ \hline
        \multicolumn{1}{|c|}{\textbf{0011}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{mov}}       & \multicolumn{1}{c|}{\textbf{Move}}                      & \multicolumn{1}{c|}{\textbf{R[ra] = R[rb] if PR}}                              \\ \hline
        \multicolumn{1}{|c|}{\textbf{0100}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{f-brzr}}    & \multicolumn{1}{c|}{\textbf{!Branch On Zero Register}}  & \multicolumn{1}{c|}{\textbf{if (R[ra] == 0) PC = R[rb] if !PR}}                \\ \hline
        \multicolumn{1}{|c|}{\textbf{0101}}   & \multicolumn{1}{c|}{\textbf{I}}     & \multicolumn{1}{c|}{\textbf{f-brzi}}    & \multicolumn{1}{c|}{\textbf{!Branch On Zero Immediate}} & \multicolumn{1}{c|}{\textbf{if (R[0] == 0) PC = PC + Imm if !PR}}              \\ \hline
        \multicolumn{1}{|c|}{\textbf{0110}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{f-jr}}      & \multicolumn{1}{c|}{\textbf{!Jump Register}}            & \multicolumn{1}{c|}{\textbf{PC = R[rb] if !PR}}                                \\ \hline
        \multicolumn{1}{|c|}{\textbf{0111}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{f-mov}}     & \multicolumn{1}{c|}{\textbf{!Move}}                     & \multicolumn{1}{c|}{\textbf{R[ra] = R[rb] if !PR}}                             \\ \hline
        \multicolumn{5}{|c|}{\textbf{Setters}}                                                                                                                                                                                                                           \\ \hline 
        \multicolumn{1}{|c|}{\textbf{1000}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{sgt}}       & \multicolumn{1}{c|}{\textbf{Set Greater Than}}          & \multicolumn{1}{c|}{\textbf{if R[ra] \texttt{>} R[rb] R[pr] := 1; R[pr] := 0}} \\ \hline
        \multicolumn{1}{|c|}{\textbf{1001}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{slt}}       & \multicolumn{1}{c|}{\textbf{Set Less Than}}             & \multicolumn{1}{c|}{\textbf{if R[ra] \texttt{<} R[rb] R[pr] := 1; R[pr] := 0}} \\ \hline
        \multicolumn{1}{|c|}{\textbf{1010}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{seq}}       & \multicolumn{1}{c|}{\textbf{Set Equal}}                 & \multicolumn{1}{c|}{\textbf{if R[ra] = R[rb] R[pr] := 1; R[pr] := 0}}          \\ \hline
        \multicolumn{1}{|c|}{\textbf{1011}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{strue}}     & \multicolumn{1}{c|}{\textbf{Set True}}                  & \multicolumn{1}{c|}{\textbf{R[pr] := 1}}                                       \\ \hline
        \multicolumn{1}{|c|}{\textbf{1100}}   & \multicolumn{1}{c|}{\textbf{EMPTY}} & \multicolumn{1}{c|}{\textbf{EMPTY}}     & \multicolumn{1}{c|}{\textbf{EMPTY}}                     & \multicolumn{1}{c|}{\textbf{EMPTY}}                                            \\ \hline
        \multicolumn{1}{|c|}{\textbf{1101}}   & \multicolumn{1}{c|}{\textbf{EMPTY}} & \multicolumn{1}{c|}{\textbf{EMPTY}}     & \multicolumn{1}{c|}{\textbf{EMPTY}}                     & \multicolumn{1}{c|}{\textbf{EMPTY}}                                            \\ \hline
        \multicolumn{1}{|c|}{\textbf{1110}}   & \multicolumn{1}{c|}{\textbf{EMPTY}} & \multicolumn{1}{c|}{\textbf{EMPTY}}     & \multicolumn{1}{c|}{\textbf{EMPTY}}                     & \multicolumn{1}{c|}{\textbf{EMPTY}}                                            \\ \hline
        \multicolumn{5}{|c|}{\textbf{Free Slot}}                                                                                                                                                                                                                         \\ \hline 
        \multicolumn{1}{|c|}{\textbf{1111}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{nop}}       & \multicolumn{1}{c|}{\textbf{No Operation}}              & \multicolumn{1}{c|}{\textbf{}}                                                 \\ \hline
      \end{tabular}
    \end{table}

    \begin{table}[H]
      \centering
      \captionsetup{labelformat=empty, skip=0pt}
      \caption{\textbf{Lanes 3 e 4 Instruções: Aritmética e Lógica}}
      \rowcolors{1}{white}{gray!20} 
      \noindent\hspace*{-2.5cm}
      \begin{tabular}{|c|*{4}{c|}}
        \hline
        \rowcolor{gray!50}
        \multicolumn{1}{|c|}{\textbf{Opcode}} & \multicolumn{1}{|c|}{\textbf{Tipo}} & \multicolumn{1}{|c|}{\textbf{Mnemonic}} & \multicolumn{1}{|c|}{\textbf{Nome}}                & \multicolumn{1}{|c|}{\textbf{Operação}}                                     \\ \hline
        \multicolumn{5}{|c|}{\textbf{Aritmética e Lógica}} \\ \hline 
        \multicolumn{1}{|c|}{\textbf{0000}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{add}}       & \multicolumn{1}{c|}{\textbf{Add}}                  & \multicolumn{1}{c|}{\textbf{R[ra] = R[ra] + R[rb] if PR}}                   \\ \hline
        \multicolumn{1}{|c|}{\textbf{0001}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{sub}}       & \multicolumn{1}{c|}{\textbf{Sub}}                  & \multicolumn{1}{c|}{\textbf{R[ra] = R[ra] - R[rb] if PR}}                   \\ \hline
        \multicolumn{1}{|c|}{\textbf{0010}}   & \multicolumn{1}{c|}{\textbf{M}}     & \multicolumn{1}{c|}{\textbf{mult-op}}   & \multicolumn{1}{c|}{\textbf{Multi Operations}}     & \multicolumn{1}{c|}{\textbf{R[ra] = R[ra] OP R[0] \texttt{|} !R[0] if PR}}  \\ \hline
        \multicolumn{1}{|c|}{\textbf{0011}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{or}}        & \multicolumn{1}{c|}{\textbf{Or}}                   & \multicolumn{1}{c|}{\textbf{R[ra] = R[ra] \texttt{|} R[rb] if PR}}          \\ \hline
        \multicolumn{1}{|c|}{\textbf{0100}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{not}}       & \multicolumn{1}{c|}{\textbf{Not}}                  & \multicolumn{1}{c|}{\textbf{R[ra] = ! R[rb] if PR}}                         \\ \hline
        \multicolumn{1}{|c|}{\textbf{0101}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{slr}}       & \multicolumn{1}{c|}{\textbf{Shift Left Register}}  & \multicolumn{1}{c|}{\textbf{R[ra] = R[ra] \texttt{<<} R[rb] if PR}}         \\ \hline
        \multicolumn{1}{|c|}{\textbf{0110}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{srr}}       & \multicolumn{1}{c|}{\textbf{Shift Right Register}} & \multicolumn{1}{c|}{\textbf{R[ra] = R[ra] \texttt{>>} R[rb] if PR}}         \\ \hline
        \multicolumn{1}{|c|}{\textbf{0111}}   & \multicolumn{1}{c|}{\textbf{EMPTY}} & \multicolumn{1}{c|}{\textbf{EMPTY}}     & \multicolumn{1}{c|}{\textbf{EMPTY}}                & \multicolumn{1}{c|}{\textbf{EMPTY}}                                         \\ \hline
        \multicolumn{1}{|c|}{\textbf{1000}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{f-add}}     & \multicolumn{1}{c|}{\textbf{Add}}                  & \multicolumn{1}{c|}{\textbf{R[ra] = R[ra] + R[rb] if !PR}}                  \\ \hline
        \multicolumn{1}{|c|}{\textbf{1001}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{f-sub}}     & \multicolumn{1}{c|}{\textbf{Sub}}                  & \multicolumn{1}{c|}{\textbf{R[ra] = R[ra] - R[rb] if !PR}}                  \\ \hline
        \multicolumn{1}{|c|}{\textbf{1010}}   & \multicolumn{1}{c|}{\textbf{M}}     & \multicolumn{1}{c|}{\textbf{f-mult-op}} & \multicolumn{1}{c|}{\textbf{Multi Operations}}     & \multicolumn{1}{c|}{\textbf{R[ra] = R[ra] OP R[0] \texttt{|} !R[0] if !PR}} \\ \hline
        \multicolumn{1}{|c|}{\textbf{1011}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{f-or}}      & \multicolumn{1}{c|}{\textbf{Or}}                   & \multicolumn{1}{c|}{\textbf{R[ra] = R[ra] \texttt{|} R[rb] if !PR}}         \\ \hline
        \multicolumn{1}{|c|}{\textbf{1100}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{f-not}}     & \multicolumn{1}{c|}{\textbf{Not}}                  & \multicolumn{1}{c|}{\textbf{R[ra] = \texttt{!} R[rb] if !PR}}               \\ \hline
        \multicolumn{1}{|c|}{\textbf{1101}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{f-slr}}     & \multicolumn{1}{c|}{\textbf{Shift Left Register}}  & \multicolumn{1}{c|}{\textbf{R[ra] = R[ra] \texttt{<<} R[rb] if !PR}}        \\ \hline
        \multicolumn{1}{|c|}{\textbf{1110}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{f-srr}}     & \multicolumn{1}{c|}{\textbf{Shift Right Register}} & \multicolumn{1}{c|}{\textbf{R[ra] = R[ra] \texttt{>>} R[rb] if !PR}}        \\ \hline
        \multicolumn{5}{|c|}{\textbf{Free Slot}}                                                                                                                                                                                                                 \\ \hline 
        \multicolumn{1}{|c|}{\textbf{1111}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{nop}}       & \multicolumn{1}{c|}{\textbf{No Operation}}         & \multicolumn{1}{c|}{\textbf{}}                                              \\ \hline
      \end{tabular}
    \end{table}

    \subsection{Implementação e Organização}

    Na implementação do nosso VLIW consumimos 4 instruções por vez, simulando uma palavra grande dessa maneira, elas são então passadas para os controles que já definem se a instrução deve ou não ser executada com base no predicado.
    Na ULA temos uma saída que retorna zero em todos os 8 bits, utilizada em casos em que a instrução não deve ser executada pelo predicado ou casos de nop. Para cada LANE existe uma UL que faz as lógicas necessárias a fim de retornar o que cada instrução precisa.
    O banco de registradores utiliza varios DEMUXes para abranger a escrita em qualquer registrador independente da LANE que envia o dado.

    \begin{table}[H]
      \rowcolors{1}{white}{gray!20} 
      \centering
      \caption{\textbf{ULA: Controle}}
      \begin{tabular}{{|c c|}}
        \hline
        \rowcolor{gray!50}
        \multicolumn{1}{|c}{\textbf{Operação}}  & \multicolumn{1}{c|}{\textbf{OP\_ULA}} \\ \hline
        \multicolumn{1}{|c}{\textbf{Add}}       & \multicolumn{1}{c|}{\textbf{000}}     \\ \hline
        \multicolumn{1}{|c}{\textbf{Sub}}       & \multicolumn{1}{c|}{\textbf{001}}     \\ \hline
        \multicolumn{1}{|c}{\textbf{Mult-op}}   & \multicolumn{1}{c|}{\textbf{010}}     \\ \hline
        \multicolumn{1}{|c}{\textbf{Or}}        & \multicolumn{1}{c|}{\textbf{011}}     \\ \hline
        \multicolumn{1}{|c}{\textbf{Not}}       & \multicolumn{1}{c|}{\textbf{100}}     \\ \hline
        \multicolumn{1}{|c}{\textbf{Sll}}       & \multicolumn{1}{c|}{\textbf{101}}     \\ \hline
        \multicolumn{1}{|c}{\textbf{Slr}}       & \multicolumn{1}{c|}{\textbf{110}}     \\ \hline
        \multicolumn{1}{|c}{\textbf{Nop}}       & \multicolumn{1}{c|}{\textbf{111}}     \\ \hline
      \end{tabular}
    \end{table}

    \begin{table}[H]
      \captionsetup{labelformat=empty, skip=0pt}
      \caption{\textbf{Lane 1 Controle: Dados}}
      \centering
      \resizebox{\textwidth}{!}{
        \begin{tabular}{@{} l c c c c c c @{}}
          \toprule
          Mnemonic & OPCODE & MOVL & MOVH & ST & LD & TRUE  \\
          \midrule
          ld       & 0000   & 0    & 0    & 0  & 1  & 1     \\
          st       & 0001   & 0    & 0    & 1  & 0  & 1     \\
          movh     & 0010   & 0    & 1    & 0  & 0  & 1     \\
          movl     & 0011   & 1    & 0    & 0  & 0  & 1     \\
          f-ld     & 0100   & 0    & 0    & 0  & 1  & 0     \\
          f-st     & 0101   & 0    & 0    & 1  & 0  & 0     \\
          f-movh   & 0110   & 0    & 1    & 0  & 0  & 0     \\
          f-movl   & 0111   & 1    & 0    & 0  & 0  & 0     \\
          empty    & 1000   & x    & x    & x  & x  & x     \\
          empty    & 1001   & x    & x    & x  & x  & x     \\
          empty    & 1010   & x    & x    & x  & x  & x     \\
          empty    & 1011   & x    & x    & x  & x  & x     \\
          empty    & 1100   & x    & x    & x  & x  & x     \\
          empty    & 1101   & x    & x    & x  & x  & x     \\
          empty    & 1110   & x    & x    & x  & x  & x     \\
          nop      & 1111   & 0    & 0    & 0  & 0  & x     \\
          \bottomrule
        \end{tabular}
      }
    \end{table}

    \begin{table}[H]
      \captionsetup{labelformat=empty, skip=0pt}
      \caption{\textbf{Lane 2 Controle: Branches}}
      \centering
      \resizebox{\textwidth}{!}{
        \begin{tabular}{@{} l c c c c c c c c @{}}
          \toprule
          Mnemonic & OPCODE & BOZR & JR & BOZI & MOVE & TRUE & PR\_OP & W\_PR  \\
          \midrule
          brzr     & 0000   & 1    & 0  & 0    & 0    & 1    & xx    & 0       \\
          brzi     & 0001   & 0    & 0  & 1    & 0    & 1    & xx    & 0       \\
          jr       & 0010   & 0    & 1  & 0    & 0    & 1    & xx    & 0       \\
          mov      & 0011   & 0    & 0  & 0    & 1    & 1    & xx    & 0       \\
          f-brzr   & 0100   & 1    & 0  & 0    & 0    & 0    & xx    & 0       \\
          f-brzi   & 0101   & 0    & 0  & 1    & 0    & 0    & xx    & 0       \\
          f-jr     & 0110   & 0    & 1  & 0    & 0    & 0    & xx    & 0       \\
          f-mov    & 0111   & 0    & 0  & 0    & 1    & 0    & xx    & 0       \\
          sgt      & 1000   & 0    & 0  & 0    & 0    & x    & 00    & 1       \\
          slt      & 1001   & 0    & 0  & 0    & 0    & x    & 10    & 1       \\
          seq      & 1010   & 0    & 0  & 0    & 0    & x    & 01    & 1       \\
          strue    & 1011   & 0    & 0  & 0    & 0    & x    & 11    & 1       \\
          empty    & 1100   & x    & x  & x    & x    & x    & xx    & x       \\
          empty    & 1101   & x    & x  & x    & x    & x    & xx    & x       \\
          empty    & 1110   & x    & x  & x    & x    & x    & xx    & x       \\
          nop      & 1111   & 0    & 0  & 0    & 0    & x    & xx    & 0       \\
          \bottomrule
        \end{tabular}
      }
    \end{table}

    \begin{table}[H]
      \captionsetup{labelformat=empty, skip=0pt}
      \caption{\textbf{Lane 3 e 4 Controle: Aritmética e Lógica}}
      \centering
      \resizebox{\textwidth}{!}{
        \begin{tabular}{@{} l c c c c @{}}
          \toprule
          Mnemonic & OPCODE & OP\_ULA & WE & TRUE  \\
          \midrule
          add       & 0000   & 000    & 1  & 1     \\
          sub       & 0001   & 001    & 1  & 1     \\
          mult-op   & 0010   & 010    & 1  & 1     \\
          or        & 0011   & 011    & 1  & 1     \\
          not       & 0100   & 100    & 1  & 1     \\
          slr       & 0101   & 101    & 1  & 1     \\
          srr       & 0110   & 110    & 1  & 1     \\
          empty     & 0111   & xxx    & x  & x     \\
          f-add     & 1000   & 000    & 1  & 0     \\
          f-sub     & 1001   & 001    & 1  & 0     \\
          f-mult-op & 1010   & 010    & 1  & 0     \\
          f-or      & 1011   & 011    & 1  & 0     \\
          f-not     & 1100   & 100    & 1  & 0     \\
          f-slr     & 1101   & 101    & 1  & 0     \\
          f-srr     & 1110   & 110    & 1  & 0     \\
          nop       & 1111   & 111    & 0  & x     \\
          \bottomrule
        \end{tabular}
      }
    \end{table}

    \subsubsection{Multi Operations}

    A instrução Multi Operations foi implementada dentro da Ula e pode ser pensada como uma extensão da mesma. A Ula passou a receber 2 bits de controle a mais, vindos da MULT-OPS, que definem qual operação fazer e então, com base no código do Op\_ula é decidido se será escolhida ou não.
    MULT-OPS opera fixamente sobre o R0, o resto do caminho é idêntico a qualquer outra operação Lógica/Aritmética


    \begin{table}[H]
      \rowcolors{1}{white}{gray!20} 
      \centering
      \caption{\textbf{Operações do Predicado: Controle}}
      \begin{tabular}{{|c c|}}
        \hline
        \rowcolor{gray!50}
        \multicolumn{1}{|c}{\textbf{Operação}} & \multicolumn{1}{c|}{\textbf{OP\_ULA}} \\ \hline
        \multicolumn{1}{|c}{\textbf{Not}}      & \multicolumn{1}{c|}{\textbf{00}}      \\ \hline
        \multicolumn{1}{|c}{\textbf{Xor}}      & \multicolumn{1}{c|}{\textbf{01}}      \\ \hline
        \multicolumn{1}{|c}{\textbf{And}}      & \multicolumn{1}{c|}{\textbf{10}}      \\ \hline
        \multicolumn{1}{|c}{\textbf{Xnor}}     & \multicolumn{1}{c|}{\textbf{11}}      \\ \hline
      \end{tabular}
    \end{table}

    \subsubsection{Move}

    Para a Instrução Move, simplesmente retornamos o valor de RB para o banco de registradores, este, com base se MOVE foi settado ou não passa o valor para o RA

    \subsubsection{Predicação}

    O registrador de predicados recebe o valor zero ou um dependendo do resultado das comparações e é sempre atualizado na borda de descida, dessa maneira é possível enviar outras instruções não dependentes de predicado em conjunto de algum dos set predicates.
    O valor dele então é utilizado pelas unidades de controle, que identificam com base na instrução se um "hit" ocorreu ou não, settando os controles de maneira apropriada.

    \begin{table}[H]
      \rowcolors{1}{white}{gray!20} 
      \centering
      \caption{\textbf{Multi Operations: Controle}}
      \begin{tabular}{{|c c|}}
        \hline
        \rowcolor{gray!50}
        \multicolumn{1}{|c}{\textbf{Operação}} & \multicolumn{1}{c|}{\textbf{OP\_PR}} \\ \hline
        \multicolumn{1}{|c}{\textbf{Greater}}  & \multicolumn{1}{c|}{\textbf{00}}      \\ \hline
        \multicolumn{1}{|c}{\textbf{Less}}     & \multicolumn{1}{c|}{\textbf{01}}      \\ \hline
        \multicolumn{1}{|c}{\textbf{Equal}}    & \multicolumn{1}{c|}{\textbf{10}}      \\ \hline
        \multicolumn{1}{|c}{\textbf{Set True}} & \multicolumn{1}{c|}{\textbf{11}}      \\ \hline
      \end{tabular}
    \end{table}


    \subsection{Assembly}

    Após a implementação da arquitetura junto com as instruções criadas chegamos ao seguinte Assembly:

    \captionsetup[lstlisting]{labelformat=empty}
    \renewcommand{\lstlistingname}{}
    \begin{lstlisting}[caption={Assembly Para Teste}]

    ;;zera os registradores e r0 = -1
    movh -1 
    nop
    sub r1 r1
    sub r2 r2

    movl -1
    nop
    nop
    sub r3 r3

    ;;r1 = -1 e r0 = -12
    movl 4
    nop
    nop
    add r1 r0 

    ;;r2 = 12 (tamanho dos vetores)
    nop
    nop
    nop
    sub r2 r0

    ;;salva valor 12 na memoria M[-1]
    st r2 r1 
    nop
    nop 
    nop

    //zera ro e r0 = 100 
    movh 6
    nop
    nop
    sub r1 r1

    ;;r1 = 100 (endereco de inicio dos vetores, r1 = A[0])
    movh 0
    nop
    nop
    add r1 r0

    ;;r0 = 1 e r1 = B[0]
    movl 1
    nop
    nop
    add r1 r2

    ;;r3 = 1
    nop
    nop
    nop
    add r3 r0

    ;;comeco do loop de preencher vetor A
    ;;3 x unrolling preenche de 4 em 4 
    ;;r1-- e r2-- 
    nop
    nop
    sub r1 r3 
    sub r2 r3

    ;;salva o valor da vez na posicao da vez
    st r2 r1
    nop
    sub r1 r3 
    sub r2 r3

    st r2 r1
    nop
    sub r1 r3 
    sub r2 r3

    st r2 r1
    nop
    sub r1 r3 
    sub r2 r3

    ;;r0 recebe o not r2 (saira do loop quando r2 for 0)
    st r2 r1
    nop 
    not r0 r2
    nop

    ;;branch para o comeco do loop
    nop
    brzi -5
    nop
    nop

    ;;r0 = -1
    movh -1
    nop
    nop
    nop

    movl -1
    nop
    nop
    nop

    ;;pega o valor 12 da memoria
    ld r2 r0 
    nop 
    nop
    nop

    ;;r1 = B[0]
    movh 1
    nop
    nop
    add r1 r2 

    ;;r0 = 19 e r1 = R[0]
    movl 3 
    nop
    nop
    add r1 r2

    ;;r3 = 20
    movh 0
    nop
    nop
    add r3 r0

    ;;r0 = 0 r3 = 32
    movl 0
    nop
    nop
    add r3 r2 

    ;;r0 = 1
    nop
    nop
    nop
    not r0 r0

    ;;comeco do loop de preencher vetor B
    ;;r3--
    ;;r1--
    nop
    nop
    sub r3 r0
    sub r1 r0

    ;;salva o valor da vez no endereco certo
    ;;r2-- (iterador)
    st r3 r1
    nop
    sub r2 r0
    nop

    ;;r0 so sera 1 quando r2 for 0 (fim do loop)
    nop
    nop
    nop
    not r0 r2

    ;;branch de loop
    nop
    brzi -4
    nop
    nop

    ;;zera r3 e comeca a calcular valor de branch
    movh 8
    nop 
    nop
    sub r3 r3

    ;;r0 = 130
    movl 12
    nop
    nop
    nop

    ;;r3 = endereco de branch
    movh -1
    nop 
    nop
    add r3 r0

    ;;r0 = -2
    movl -2
    nop
    nop
    nop

    ;;salva valor de r3 na memoria
    st r3 r0
    nop
    nop
    nop

    ;;r0 = -1
    movl -1
    nop
    nop
    nop

    ;;r2 = 12
    ld r2 r0 
    nop
    nop
    nop

    ;;r0 = -3
    movl -3
    nop
    nop
    nop

    ;;salva iterador na memoria
    st r2 r0 
    nop
    nop
    nop

    ;;comeco do loop de soma
    ;;2xUnrolling (preenche 3 posicoes por vez)
    ;;r0 = -1
    movl -1 
    nop
    nop
    nop

    ;;r2 = 12 (tamanho vetor)
    ld r2 r0
    nop
    nop
    nop

    ;; r1--
    nop
    nop
    add r1 r0 
    nop

    ;;baixa valor da vez de A
    ;;r1 = B da vez
    ld r0 r1 
    nop
    nop
    add r1 r2 

    ;;baixa valor da vez de B
    ;;r1 = R da vez (R[x])
    ld r3 r1 
    nop
    nop
    add r1 r2 

    ;;r3 = soma de A[x] e B[x]
    movh -1
    nop
    nop
    add r3 r0 

    ;;salva a soma em R
    ;;r1 = B da vez
    st r3 r1
    nop
    nop
    sub r1 r2

    ;;r0 = -1
    ;;r1 = A da vez
    movl -1
    nop
    nop
    sub r1 r2 

    ;;r1 -- (proxima posicao)
    nop
    nop
    nop
    add r1 r0 

    ;;baixa valor da vez de A
    ;;r1 = B da vez
    ld r0 r1 
    nop
    nop
    add r1 r2 

    ;;baixa valor da vez de B
    ;;r1 = R da vez (R[x])
    ld r3 r1 
    nop
    nop
    add r1 r2 

    ;;r3 = soma de A[x] e B[x]
    movh -1
    nop
    nop
    add r3 r0 

    ;;salva a soma em R
    ;;r1 = B da vez
    st r3 r1
    nop
    nop
    sub r1 r2

    ;;r0 = -1
    ;;r1 = A da vez
    movl -1
    nop
    nop
    sub r1 r2 

    ;;r1 -- (proxima posicao)
    nop
    nop
    nop
    add r1 r0 

    ;;baixa valor da vez de A
    ;;r1 = B da vez
    ld r0 r1 
    nop
    nop
    add r1 r2 

    ;;baixa valor da vez de B
    ;;r1 = R da vez (R[x])
    ld r3 r1 
    nop
    nop
    add r1 r2 

    ;;r3 = soma de A[x] e B[x]
    movh -1
    nop
    nop
    add r3 r0 

    ;;salva a soma em R
    ;;r1 = B da vez
    st r3 r1
    nop
    nop
    sub r1 r2

    ;;r0 = -2 
    movl -2
    nop
    nop
    sub r1 r2 

    ;;baixa o valor de branch da memoria em r3
    ld r3 r0 
    nop
    nop
    nop

    ;;r0 = -3
    movl -3
    nop
    nop
    nop

    ;;baixa iterador da memoria em r2
    ld r2 r0 
    nop
    nop
    nop 

    ;;r2 = r2 - 3 (iterador - 3, pois faz 3 por loop)
    nop
    nop
    nop
    add r2 r0 

    ;;salva o iterador na memoria
    ;;r0 recebe !iterador (so saira do loop quando iterador for 0)
    st r2 r0 
    nop
    nop
    not r0 r2

    ;;branch para comeco do loop
    movh -1
    brzr r0 r3
    nop
    nop

    ;; zera r0
    nop
    nop
    nop
    sub r0 r0

    ;;HALT
    nop
    brzi 0
    nop 
    nop

    \end{lstlisting}

    Além deste código, um teste para mostrar a eficiência dos predicados também foi criado:

    \captionsetup[lstlisting]{labelformat=empty}
    \renewcommand{\lstlistingname}{}
    \begin{lstlisting}[caption={Assembly Para de Predicados}]

    ;;vai executar as proximas instrucoes ate o proximo branch
    nop
    strue
    nop
    nop

    ;;zera r0 usando xor do mult-ops
    nop
    nop
    mult-op r0 1
    sub r3 r3

    ;;r0 = 10 e zera r1 e r2 com um and 0
    movl 10
    nop
    mult-op r1 2
    mult-op r2 2

    ;;r1 e r3 recebe o valor de 10
    ;;r2 = 1
    nop
    mov r1 r0
    add r3 r0
    not r2 r2

    ;; deve executar as instrucoes normais
    ;; predicado se r1 for maior que r2 executa 
    ;; as instrucoes normais ate o proximo set
    ;; caso seja falso, executa as f-.
    ;; zera r0 com xor
    nop
    sgt r1 r2
    mult-op r0 1 
    nop

    ;;deve executar r1 = r1 - r2
    nop
    nop
    sub r1 r2
    nop

    ;;r2 nao deve receber valor de r1
    nop
    f-mov r2 r1
    nop
    nop

    ;; deve executar as instrucoes 'f-'
    ;; se r1 igual a r2 
    nop
    seq r1 r2
    nop
    nop

    ;; deve guardar o valor 10 no endereco 10 da memoria
    ;; deve pular para instrucao strue
    ;; r2 deve ser igual a 10
    ;; nao deve zerar r1
    f-st r3 r3 
    f-brzi 2
    f-add r2 r1
    sub r1 r1

    ;;nao deve fazer o load
    f-ld r3 r3
    nop
    nop
    nop

    ;;seta novamente para true
    ;;ira executar normalmente as instrucoes a partir daqui
    nop 
    strue
    nop
    nop

    ;;halt
    nop
    brzi 0
    nop
    nop

    \end{lstlisting}

    \section{Vetorial}

    \subsection{Arquitetura}

    No processador vetorial temos 2 caminhos que as instruções podem seguir, o caminho Escalar, que funciona como um monociclo comum e o caminho Vetorial, este possui 4 "lanes" que executam a mesma instrução, cada uma dessas lanes possui seu próprio banco de registradores, memória e ula.
    A sacada do processador vetorial é que cada uma das lanes possui um ID fixo nos seus respectivos R0s, o que possibilita fazer preenchimento e operações mais eficientes com vetores.
    É importante ressaltar que não existe instrução que atua de forma escalar e vetorial ao mesmo tempo.

    \subsection{ISA}

    A ISA que iremos utilizar para o nosso Vetorial é a Sagui em Bando (SB).
    A SB consiste em uma ISA também parecida com reduxV e segue as seguintes especificações:
    Ela possui 8 bits com 3 registradores de propósito geral para a área scalar, e R0 fixo em 0 além de uma memória exclusiva. A parte vetorial é muito semelhante, porém o R0 varia entre 0 e 3.
    Assim como o reduxV teremos 4 bits para os opcodes
    
    Por padrão, os formatos das instruções são os mesmos do Sagui de Rabo Longo

    \subsection{Motivações e Instruções}

    Para este processador tentamos dar mais opções à parte scalar, facilitando a gama de operações e o número de operações, fazendo com que seja mais fácil interagir com loops e como consequencia mais fácil de utilizar a parte vetorial do processador.
    Mais que isso, fizemos uma instrução que opera um loop no próprio hardware, dando uma liberdade grande ao programador de como trabalhar com nossa ISA.

    \begin{table}[H]
      \centering
      \captionsetup{labelformat=empty, skip=0pt}
      \caption{\textbf{Instruções}}
      \noindent\hspace*{-2.85cm}
      \rowcolors{1}{white}{gray!20} 
      \begin{tabular}{|c|*{4}{c|}}
        \hline
        \rowcolor{gray!50}
        \multicolumn{1}{|c|}{\textbf{Opcode}} & \multicolumn{1}{|c|}{\textbf{Tipo}} & \multicolumn{1}{|c|}{\textbf{Mnemonic}} & \multicolumn{1}{|c|}{\textbf{Nome}}                   & \multicolumn{1}{|c|}{\textbf{Operação}}                                 \\ \hline
        \multicolumn{1}{|c|}{\textbf{0000}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{s.ld}}      & \multicolumn{1}{c|}{\textbf{Load}}                    & \multicolumn{1}{c|}{\textbf{SR[ra] = M[ SR[rb] ]}}                      \\ \hline
        \multicolumn{1}{|c|}{\textbf{0001}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{s.st}}      & \multicolumn{1}{c|}{\textbf{Store}}                   & \multicolumn{1}{c|}{\textbf{M[ SR[rb] ] = SR[ra]}}                      \\ \hline
        \multicolumn{1}{|c|}{\textbf{0010}}   & \multicolumn{1}{c|}{\textbf{I}}     & \multicolumn{1}{c|}{\textbf{s.movh}}    & \multicolumn{1}{c|}{\textbf{Move High}}               & \multicolumn{1}{c|}{\textbf{SR[1] = {Imm., SR[1](3:0)}}}                \\ \hline
        \multicolumn{1}{|c|}{\textbf{0011}}   & \multicolumn{1}{c|}{\textbf{I}}     & \multicolumn{1}{c|}{\textbf{s.movl}}    & \multicolumn{1}{c|}{\textbf{Move Low}}                & \multicolumn{1}{c|}{\textbf{SR[1] = {SR[1](7:4), Imm.}}}                \\ \hline
        \multicolumn{1}{|c|}{\textbf{0100}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{s.add}}     & \multicolumn{1}{c|}{\textbf{Add}}                     & \multicolumn{1}{c|}{\textbf{SR[ra] = SR[ra] \texttt{+} SR[rb]}}         \\ \hline
        \multicolumn{1}{|c|}{\textbf{0101}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{s.sub}}     & \multicolumn{1}{c|}{\textbf{Sub}}                     & \multicolumn{1}{c|}{\textbf{SR[ra] = SR[ra] \texttt{-} SR[rb]}}         \\ \hline
        \multicolumn{1}{|c|}{\textbf{0110}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{s.and}}     & \multicolumn{1}{c|}{\textbf{And}}                     & \multicolumn{1}{c|}{\textbf{SR[ra] = SR[ra] \& SR[rb]}}                 \\ \hline
        \multicolumn{1}{|c|}{\textbf{0111}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{s.brzr}}    & \multicolumn{1}{c|}{\textbf{Branch On Zero Register}} & \multicolumn{1}{c|}{\textbf{if (SR[ra] == 0) PC = SR[rb]}}              \\ \hline
        \multicolumn{1}{|c|}{\textbf{1000}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{v.ld}}      & \multicolumn{1}{c|}{\textbf{Load}}                    & \multicolumn{1}{c|}{\textbf{VR[ra] = M[ VR[rb] ]}}                      \\ \hline
        \multicolumn{1}{|c|}{\textbf{1001}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{v.st}}      & \multicolumn{1}{c|}{\textbf{Store}}                   & \multicolumn{1}{c|}{\textbf{M[ VR[rb] ] = VR[ra]}}                      \\ \hline
        \multicolumn{1}{|c|}{\textbf{1010}}   & \multicolumn{1}{c|}{\textbf{I}}     & \multicolumn{1}{c|}{\textbf{v.movh}}    & \multicolumn{1}{c|}{\textbf{Move High}}               & \multicolumn{1}{c|}{\textbf{VR[1] = {Imm., VR[1](3:0)}}}                \\ \hline
        \multicolumn{1}{|c|}{\textbf{1011}}   & \multicolumn{1}{c|}{\textbf{I}}     & \multicolumn{1}{c|}{\textbf{v.movl}}    & \multicolumn{1}{c|}{\textbf{Move Low}}                & \multicolumn{1}{c|}{\textbf{VR[1] = {VR[1](7:4), Imm.}}}                \\ \hline
        \multicolumn{1}{|c|}{\textbf{1100}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{v.add}}     & \multicolumn{1}{c|}{\textbf{Add}}                     & \multicolumn{1}{c|}{\textbf{VR[ra] = VR[ra] \texttt{+} VR[rb]}}         \\ \hline
        \multicolumn{1}{|c|}{\textbf{1101}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{v.sub}}     & \multicolumn{1}{c|}{\textbf{Sub}}                     & \multicolumn{1}{c|}{\textbf{VR[ra] = VR[ra] \texttt{-} VR[rb]}}         \\ \hline
        \multicolumn{1}{|c|}{\textbf{1110}}   & \multicolumn{1}{c|}{\textbf{M}}     & \multicolumn{1}{c|}{\textbf{s.inc-ops}} & \multicolumn{1}{c|}{\textbf{Inc-Ops}}                 & \multicolumn{1}{c|}{\textbf{SR[ra] = [RA] OP [RB] \texttt{||} OP [RA]}} \\ \hline
        \multicolumn{1}{|c|}{\textbf{1111}}   & \multicolumn{1}{c|}{\textbf{R}}     & \multicolumn{1}{c|}{\textbf{s.rep}}     & \multicolumn{1}{c|}{\textbf{Rep}}                     & \multicolumn{1}{c|}{\textbf{Repeat Next RB Instructions RA times}}      \\ \hline
      \end{tabular}
    \end{table}

    \subsubsection{Inc-Ops}

    A instrução Inc-Ops realiza diversas operações com base em um imediato passado e um registrador.

    Segue o seu formato:

    \begin{table}[h]
      \captionsetup{labelformat=empty, skip=0pt}
      \caption{\textbf{Formato Novo:} Tipo Misto}
      \centering
      \rowcolors{1}{white}{red!20} 
      \begin{tabular}{|c|*{8}{c|}}
        \hline
        \rowcolor{red!50}
        \multicolumn{9}{|c|}{\textbf{Tipo M}} \\ \hline
        \textbf{Bits} & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\ \hline
        & \multicolumn{4}{c|}{\textbf{Opcode}} & \multicolumn{2}{c|}{\textbf{Ra}} & \multicolumn{2}{c|}{\textbf{Imm}} \\ \hline
      \end{tabular}
    \end{table}

    \subsubsection{Rep}
    
    A instrução Rep recebe dois registradores, o primeiro (RA) dita a quantidade de vezes que as proximas n instruções (RB) devem ser executadas.
    
    \subsection{Implementação e Organização}

    Implementamos o processador vetorial de modo que a leitura da instrução passa um NOP para a parte scalar ou para a parter vetorial, dependendo do que foi recebido. 
    Além do mais implementamos um pipeline com 5 subdivisões utilizando uma Unidade hazard, o qual atua tanto na parte scalar quanto na parte vetorial.

    \begin{table}[H]
      \captionsetup{labelformat=empty, skip=0pt}
      \caption{\textbf{Controle: Vetorial}}
      \centering
      \resizebox{\textwidth}{!}{
        \begin{tabular}{@{} l c c c c c c c c c c c @{}}
          \toprule
          Mnemonic  & OPCODE & ST\_SR & ST\_V & WE\_SR & WE\_V & MOV & REP & BRANCH & LD & OP\_ULA & HEX\_VALUE \\
          \midrule
          s.ld      & 0000   & 0      & 0     & 1      & 0     & 0   & 0   & 0      & 1  & 111     & 0x10F      \\
          s.st      & 0001   & 1      & 0     & 0      & 0     & 0   & 0   & 0      & 0  & 111     & 0x407      \\
          s.movh    & 0010   & 0      & 0     & 1      & 0     & 1   & 0   & 0      & 0  & 010     & 0x142      \\
          s.movl    & 0011   & 0      & 0     & 1      & 0     & 1   & 0   & 0      & 0  & 011     & 0x143      \\
          s.add     & 0100   & 0      & 0     & 1      & 0     & 0   & 0   & 0      & 0  & 100     & 0x104      \\
          s.sub     & 0101   & 0      & 0     & 1      & 0     & 0   & 0   & 0      & 0  & 101     & 0x105      \\
          s.and     & 0110   & 0      & 0     & 1      & 0     & 0   & 0   & 0      & 0  & 110     & 0x106      \\
          s.brzr    & 0111   & 0      & 0     & 0      & 0     & 0   & 0   & 1      & 0  & 111     & 0x017      \\
          v.ld      & 1000   & 0      & 0     & 0      & 1     & 0   & 0   & 0      & 1  & 111     & 0x08F      \\
          v.st      & 1001   & 0      & 1     & 0      & 0     & 0   & 0   & 0      & 0  & 111     & 0x207      \\
          v.movh    & 1010   & 0      & 0     & 0      & 1     & 1   & 0   & 0      & 0  & 010     & 0x0C2      \\
          v.movl    & 1011   & 0      & 0     & 0      & 1     & 1   & 0   & 0      & 0  & 011     & 0x0C3      \\
          v.add     & 1100   & 0      & 0     & 0      & 1     & 0   & 0   & 0      & 0  & 100     & 0x084      \\
          v.sub     & 1101   & 0      & 0     & 0      & 1     & 0   & 0   & 0      & 0  & 101     & 0x085      \\
          s.inc-ops & 1110   & 0      & 0     & 1      & 0     & 0   & 0   & 0      & 0  & 000     & 0x100      \\
          s.rep     & 1111   & 0      & 0     & 0      & 0     & 0   & 1   & 0      & 0  & 111     & 0x027      \\
          \bottomrule
        \end{tabular}
      }
    \end{table}

    \subsubsection{Inc-Ops}

    Uma novo controle chamado inc-ops foi adicionado a fim de comtemplar a escolha da operação do inc-ops dentro da ula, ou seja, temos um mux para escolher a operação do Inc-Ops e então o seu resultado é passado para o mux normal da Ula.

    \begin{table}[H]
      \rowcolors{1}{white}{gray!20} 
      \caption{\textbf{Inc-Ops: Controle}}
      \centering
      \begin{tabular}{{|c c|}}
        \hline
        \rowcolor{gray!50}
        \multicolumn{1}{|c}{\textbf{Operação}} & \multicolumn{1}{c|}{\textbf{INC-OPS}} \\ \hline
        \multicolumn{1}{|c}{\textbf{Not}}      & \multicolumn{1}{c|}{\textbf{00}}      \\ \hline
        \multicolumn{1}{|c}{\textbf{Inc 1}}    & \multicolumn{1}{c|}{\textbf{01}}      \\ \hline
        \multicolumn{1}{|c}{\textbf{Or}}       & \multicolumn{1}{c|}{\textbf{10}}      \\ \hline
        \multicolumn{1}{|c}{\textbf{Dec 1}}    & \multicolumn{1}{c|}{\textbf{11}}      \\ \hline
      \end{tabular}
    \end{table}

    \subsubsection{Rep}

    A instrução Rep utiliza de alguns registradores a parte para saber quando deve parar de realizar a repetição. Quando ela é processada, um desses registradores recebe a quantidade de vezes que as proximas instruções devem ser repetidas, um outro registrador recebe quantas instruções devem ser processadas.
    Todo clock dimninui o segundo registrador em 1 e quando ele chega em zero ele é retornado para a quantidade de instruções que devem ser repetidas e o primeiro tem seu valor reduzido em 1.
    Assim conseguimos administrar o total de vezes que as instruções serão repetidas.
    Por fim, existe um terceiro registrador que guarda o endereço de inicio do loop, toda vez que o segundo registrador é zerado, o valor desse registrador é passado para o PC

    \subsection{Assembly}

    O primeiro assembly criado sem utlizar as instruções extras implementadas ficou da seguinte maneira:

    %% COLOCARE OS DOIS ASSEMBLYS

    Após a implementação das instruções novas conseguimos o seguinte resultado:



    \section{Conclusão}

    Assim realizamos a implementação de duas arquiteturas de processadores diferentes, implementando instruções CISC, predicação, pipelines e loops em hardware. Além disso também aplicamos técnicas como loop Unroling.
    
    Todo esse processo foi extremamente interessante e cada etapa foi bem desafiadora.

\end{document} 
